subroutine l2appr ( t, n, k, q, diag, bcoef )

!*****************************************************************************80
!
!! L2APPR constructs a weighted L2 spline approximation to given data.
!
!  Discussion:
!
!    The routine constructs the weighted discrete L2-approximation by 
!    splines of order K with knot sequence T(1:N+K) to 
!    given data points ( TAU(1:NTAU), GTAU(1:NTAU) ).  
!
!    The B-spline coefficients BCOEF of the approximating spline are 
!    determined from the normal equations using Cholesky's method.
!
!  Method:
!
!    The B-spline coefficients of the L2-approximation are determined as the 
!    solution of the normal equations, for 1 <= I <= N:
!
!      sum ( 1 <= J <= N ) ( B(I), B(J) ) * BCOEF(J) = ( B(I), G ).
!
!    Here, B(I) denotes the I-th B-spline, G denotes the function to
!    be approximated, and the inner product of two functions F and G 
!    is given by
!
!      ( F, G ) = sum ( 1 <= I <= NTAU ) WEIGHT(I) * F(TAU(I)) * G(TAU(I)).
!
!    The arrays TAU and WEIGHT are given in common block DATA, as is the 
!    array GTAU(1:NTAU) = G(TAU(1:NTAU)).
!
!    The values of the B-splines B(1:N) are supplied by BSPLVB.
!
!    The coefficient matrix C, with
!
!       C(I,J) = ( B(I), B(J) )
!
!    of the normal equations is symmetric and (2*K-1)-banded, therefore
!    can be specified by giving its K bands at or below the diagonal. 
!
!    For I = 1:N and J = I:min(I+K-1,N), we store
!
!      ( B(I), B(J) ) = C(I,J) 
!
!    in
!
!      Q(I-J+1,J), 
!
!    and the right hand side
!
!      ( B(I), G )  
!
!    in
!
!      BCOEF(I).
!
!    Since B-spline values are most efficiently generated by finding
!    simultaneously the value of every nonzero B-spline at one point,
!    the entries of C (that is, of Q), are generated by computing, for
!    each LL, all the terms involving TAU(LL) simultaneously and adding
!    them to all relevant entries.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663,
!    LC: QA1.A647.v27.
!
!  Parameters:
!
!    Input, real ( kind = 8 ) T(N+K), the knot sequence.
!
!    Input, integer ( kind = 4 ) N, the dimension of the space of splines 
!    of order K with knots T.
!
!    Input, integer ( kind = 4 ) K, the order of the splines.
!
!    Workspace, real ( kind = 8 ) Q(K,N), used to store the K lower 
!    diagonals of the Gramian matrix C.
!
!    Workspace, real ( kind = 8 ) DIAG(N), used in BCHFAC.
!
!    Output, real ( kind = 8 ) BCOEF(N), the B-spline coefficients of
!    the L2 approximation to the data.
!
  implicit none

  integer ( kind = 4 ) k
  integer ( kind = 4 ) n
  integer ( kind = 4 ), parameter :: ntmax = 200

  real ( kind = 8 ) bcoef(n)
  real ( kind = 8 ) biatx(k)
  real ( kind = 8 ) diag(n)
  real ( kind = 8 ) dw
  real ( kind = 8 ) gtau
  integer ( kind = 4 ) i
  integer ( kind = 4 ) j
  integer ( kind = 4 ) jj
  integer ( kind = 4 ) left
  integer ( kind = 4 ) leftmk
  integer ( kind = 4 ) ll
  integer ( kind = 4 ) mm
  integer ( kind = 4 ) ntau
  real ( kind = 8 ) q(k,n)
  real ( kind = 8 ) t(n+k)
  real ( kind = 8 ) tau
  real ( kind = 8 ) totalw
  real ( kind = 8 ) weight

  save / i4data /
  save / r8data /

  common / i4data / ntau
  common / r8data / tau(ntmax), gtau(ntmax), weight(ntmax), totalw

  bcoef(1:n) = 0.0D+00
  q(1:k,1:n) = 0.0D+00

  left = k
  leftmk = 0
  
  do ll = 1, ntau
!
!  Locate LEFT such that TAU(LL) is in ( T(LEFT), T(LEFT+1) ).
!
    do

      if ( left == n ) then
        exit
      end if

      if ( tau(ll) < t(left+1) ) then
        exit
      end if

      left = left + 1
      leftmk = leftmk + 1

    end do

    call bsplvb ( t, k, 1, tau(ll), left, biatx )
!
!  BIATX(MM) contains the value of B(LEFT-K+MM) at TAU(LL).
!
!  Hence, with DW = BIATX(MM) * WEIGHT(LL), the number DW * GTAU(LL)
!  is a summand in the inner product
!
!    ( B(LEFT-K+MM), G)
!
!  which goes into  BCOEF(LEFT-K+MM)
!  and the number BIATX(JJ)*DW is a summand in the inner product
!    (B(LEFT-K+JJ), B(LEFT-K+MM)), into  Q(JJ-MM+1,LEFT-K+MM)
!  since  (LEFT-K+JJ)-(LEFT-K+MM)+1 = JJ - MM + 1.
!
    do mm = 1, k
    
      dw = biatx(mm) * weight(ll)
      j = leftmk + mm
      bcoef(j) = dw * gtau(ll) + bcoef(j)
      i = 1
      
      do jj = mm, k
        q(i,j) = biatx(jj) * dw + q(i,j)
        i = i + 1
      end do
      
    end do
    
  end do
!
!  Construct the Cholesky factorization for C in Q, then 
!  use it to solve the normal equations
!
!    C * X = BCOEF
!
!  for X, and store X in BCOEF.
!
  call bchfac ( q, k, n, diag )
  
  call bchslv ( q, k, n, bcoef )
  
  return
end
subroutine l2err ( iprfun, ftau, error )

!*****************************************************************************80
!
!! L2ERR computes the errors of an L2 approximation.
!
!  Discussion:
!
!    This routine computes various errors of the current L2 approximation, 
!    whose piecewise polynomial representation is contained in common 
!    block APPROX, to the given data contained in common block DATA.  
!
!    It prints out the average error ERRL1, the L2 error ERRL2, and the
!    maximum error ERRMAX.
!
!  Modified:
!
!    16 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663,
!    LC: QA1.A647.v27.
!
!  Parameters: 
!
!    Input, integer ( kind = 4 ) IPRFUN.  If IPRFUN = 1, the routine prints out
!    the value of the approximation as well as its error at
!    every data point.
!
!    Output, real ( kind = 8 ) FTAU(NTAU), contains the value of the computed
!    approximation at each value TAU(1:NTAU).
!
!    Output, real ( kind = 8 ) ERROR(NTAU), with 
!      ERROR(I) = SCALE * ( G - F )(TAU(I)).  Here, SCALE equals 1
!    in case IPRFUN /= 1, or the absolute error is greater than 100 
!    somewhere.  Otherwise, SCALE is such that the maximum of the
!    absolute value of ERROR(1:NTAU) lies between 10 and 100.  This
!    makes the printed output more illustrative.
!
  implicit none

  integer ( kind = 4 ), parameter :: lpkmax = 100
  integer ( kind = 4 ), parameter :: ntmax = 200
  integer ( kind = 4 ), parameter :: ltkmax = 2000

  integer ( kind = 4 ) ntau

  real ( kind = 8 ) brk
  real ( kind = 8 ) coef
  real ( kind = 8 ) err
  real ( kind = 8 ) errl1
  real ( kind = 8 ) errl2
  real ( kind = 8 ) errmax
  real ( kind = 8 ) error(ntau)
  real ( kind = 8 ) ftau(ntau)
  real ( kind = 8 ) gtau
  integer ( kind = 4 ) ie
  integer ( kind = 4 ) iprfun
  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  integer ( kind = 4 ) ll
  real ( kind = 8 ) ppvalu
  real ( kind = 8 ) scale
  real ( kind = 8 ) tau
  real ( kind = 8 ) totalw
  real ( kind = 8 ) weight

  save / approx /
  save / i4data /
  save / r8data /

  common / approx / brk(lpkmax), coef(ltkmax), l, k
  common / i4data / ntau
  common / r8data / tau(ntmax), gtau(ntmax), weight(ntmax), totalw

  errl1 = 0.0D+00
  errl2 = 0.0D+00
  errmax = 0.0D+00

  do ll = 1, ntau

    ftau(ll) = ppvalu ( brk, coef, l, k, tau(ll), 0 )

    error(ll) = gtau(ll) - ftau(ll)
    err = abs(error(ll))

    if ( errmax < err ) then
      errmax = err
    end if

    errl1 = errl1 + err * weight(ll)
    errl2 = errl2 + err**2 * weight(ll)

  end do

  errl1 = errl1 / totalw
  errl2 = sqrt ( errl2 / totalw )

  write ( *, '(a)' ) ' '
  write ( *, '(a,g14.6)' ) '  Least square error = ', errl2
  write ( *, '(a,g14.6)' ) '  Average error      = ', errl1
  write ( *, '(a,g14.6)' ) '  Maximum error      = ', errmax
  write ( *, '(a)' ) ' '
  
  if ( iprfun /= 1 ) then
    return
  end if
!
!  Scale error curve and print.
!
  ie = 0
  scale = 1.0D+00

  if ( errmax < 10.0D+00 ) then
  
    do ie = 1, 9
      scale = scale * 10.0D+00
      if ( 10.0D+00 <= errmax * scale ) then
        exit
      end if
    end do

  end if  

  error(1:ntau) = error(1:ntau) * scale
  
  write ( *, '(a)' ) ' '
  write ( *, '(a)' ) '  Approximation and scaled error curve'
  write ( *, '(a)' ) ' '
  write ( *, '(a,i1)' ) &
    '       Data point       Approximation   Deviation x 10**', ie
  write ( *, '(a)' ) ' '
  write ( *, '(i4,f16.8,f16.8,f17.6)' ) &
    ( ll, tau(ll), ftau(ll), error(ll), ll = 1, ntau )

  return
end
subroutine l2knts ( brk, l, k, t, n )

!*****************************************************************************80
!
!! L2KNTS converts breakpoints to knots.
!
!  Discussion:
!
!    The breakpoint sequence BREAK is converted into a corresponding 
!    knot sequence T to allow the representation of a piecewise
!    polynomial function of order K with K-2 continuous derivatives 
!    as a spline of order K with knot sequence T. 
!
!    This means that T(1:N+K) = BREAK(1) K times, then BREAK(2:L), 
!    then BREAK(L+1) K times.  
!
!    Therefore, N = K - 1 + L.
!
!  Modified:
!
!    14 February 2007
!
!  Author:
!
!    Carl DeBoor
!
!  Reference:
!
!    Carl DeBoor,
!    A Practical Guide to Splines,
!    Springer, 2001,
!    ISBN: 0387953663,
!    LC: QA1.A647.v27.
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) K, the order.
!
!    Input, integer ( kind = 4 ) L, the number of polynomial pieces.
!
!    Input, real ( kind = 8 ) BREAK(L+1), the breakpoint sequence.
!
!    Output, real ( kind = 8 ) T(N+K), the knot sequence.
!
!    Output, integer ( kind = 4 ) N, the dimension of the corresponding spline 
!    space of order K.
!
  implicit none

  integer ( kind = 4 ) k
  integer ( kind = 4 ) l
  integer ( kind = 4 ) n

  real ( kind = 8 ) brk(l+1)
  real ( kind = 8 ) t(k-1+l+k)

  n = k - 1 + l

  t(1:k-1) = brk(1)
  t(k:n) = brk(1:l) 
  t(n+1:n+k) = brk(l+1)
 
  return
end

